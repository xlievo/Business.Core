<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Business.Core</name>
    </assembly>
    <members>
        <member name="T:Business.Core.Annotations.AttributeBase.MetaData.DeclaringType">
            <summary>
            Source types that declare this feature
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.AttributeBase.MetaData.Type">
            <summary>
            Gets the fully qualified type name, including the namespace but not the assembly
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.AttributeBase.MetaData.Declaring">
            <summary>
            Declare the source of this feature
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.AttributeBase.Item(System.String)">
            <summary>
            Accessor
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.AttributeBase.Clone``1">
            <summary>
            Depth Clone
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Business.Core.Annotations.TestingAttribute.#ctor(System.String,System.Object,System.String,System.String,System.String)" -->
        <member name="P:Business.Core.Annotations.TestingAttribute.Name">
            <summary>
            test key
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.TestingAttribute.Value">
            <summary>
            test args
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.TestingAttribute.Result">
            <summary>
            result
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.TestingAttribute.Token">
            <summary>
            test fixed roken
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.TestingAttribute.TokenMethod">
            <summary>
            Support method Result.D, input json array [\"Login\",\"{User:\\\"aaa\\\",Password:\\\"123456\\\"}\"]
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.TestingAttribute.Method">
            <summary>
            Target method
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.IgnoreMode.Method">
            <summary>
            Ignore business methods
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.IgnoreMode.Arg">
            <summary>
            Ignore document presentation
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.IgnoreMode.ArgChild">
            <summary>
            Ignore document child presentation
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.IgnoreMode.BusinessArg">
            <summary>
            Ignoring global parameter annotations injection
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.Ignore">
            <summary>
            The Method and Property needs to be ignored and will not be a proxy
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.Info">
            <summary>
            Business info
            </summary>
        </member>
        <member name="M:Business.Core.Annotations.Info.#ctor(System.String)">
            <summary>
            Business Formal Name
            </summary>
            <param name="businessName"></param>
        </member>
        <member name="P:Business.Core.Annotations.Info.BusinessName">
            <summary>
            Business formal name
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.Info.Alias">
            <summary>
            Business friendly alias
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.Info.TypeFullName">
            <summary>
            Type fullName
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.Info.DocPhysicalPath">
            <summary>
            Document physical path
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.Info.DocFileName">
            <summary>
            Document file name
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.Info.CommandGroupDefault">
            <summary>
            Group default value
            </summary>
        </member>
        <member name="M:Business.Core.Annotations.UseAttribute.#ctor(System.Boolean)">
            <summary>
            Injecting Objects Corresponding to Parameters
            </summary>
            <param name="parameterName">Use parameter names to correspond to injection objects</param>
        </member>
        <member name="P:Business.Core.Annotations.UseAttribute.ParameterName">
            <summary>
            Use parameter names to correspond to injection objects
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.AliasAttribute">
            <summary>
            Friendly name
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.AliasAttribute.Name">
            <summary>
            Friendly name
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.DocGroupAttribute">
            <summary>
            Document grouping configuration
            </summary>
        </member>
        <member name="M:Business.Core.Annotations.DocGroupAttribute.#ctor(System.String)">
            <summary>
            Grouping name
            </summary>
            <param name="group"></param>
        </member>
        <member name="P:Business.Core.Annotations.DocGroupAttribute.Group">
            <summary>
            Grouping name
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.DocGroupAttribute.Position">
            <summary>
            position
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.DocGroupAttribute.Badge">
            <summary>
            badge
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.DocGroupAttribute.Active">
            <summary>
            Allowed to expand
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.DocAttribute">
            <summary>
            Document configuration
            </summary>
        </member>
        <member name="M:Business.Core.Annotations.DocAttribute.#ctor(System.String)">
            <summary>
            Friendly name
            </summary>
            <param name="alias"></param>
        </member>
        <member name="P:Business.Core.Annotations.DocAttribute.Group">
            <summary>
            Method alias grouping
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.DocAttribute.Alias">
            <summary>
            Friendly name
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.DocAttribute.Position">
            <summary>
            position
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.DocAttribute.Badge">
            <summary>
            badge
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.LoggerAttribute.LogType">
            <summary>
            Record type
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.LoggerAttribute.CanWrite">
            <summary>
            Allow record
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.LoggerAttribute.CanValue">
            <summary>
            Allowed to return to parameters
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.LoggerAttribute.CanResult">
            <summary>
            Allowed to return to results
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.LoggerValueMode">
            <summary>
            Record parameter model
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.LoggerValueMode.All">
            <summary>
            Allow selective recording of some parameters
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.LoggerValueMode.Select">
            <summary>
            All parameter Records
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.LoggerValueMode.No">
            <summary>
            No records
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.GroupAttribute.Group">
            <summary>
            Used for the command group
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.ArgumentAttribute">
            <summary>
            Base class for all attributes that apply to parameters
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.MetaData.Business">
            <summary>
            Declaring
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.MetaData.BusinessName">
            <summary>
            Business Friendly Name
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.MetaData.Filter">
            <summary>
            This value indicates that the annotation is a filter model used to apply parameters. The default value is UseNotParameterLevel, which means that the injection parameters are filtered out and the annotation is non parameter level
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.CollectionItem">
            <summary>
            Whether to apply to each item of a set parameter
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.CanNull">
            <summary>
            By checking the Allow null value, Default to true
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.State">
            <summary>
            Used to return state
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.Message">
            <summary>
            Used to return error messages
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.ArgumentAttribute.Alias">
            <summary>
            Amicable name
            </summary>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.Proces(System.Object)">
            <summary>
            Start processing the Parameter object, By this.ResultCreate() method returns
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.Proces``1(System.Object)">
            <summary>
            Start processing the Parameter object, By this.ResultCreate() method returns
            </summary>
            <typeparam name="Type"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.Proces(System.Object,System.Int32,System.Object)">
            <summary>
            Start processing the Parameter object, By this.ResultCreate() method returns
            </summary>
            <param name="value"></param>
            <param name="collectionIndex"></param>
            <param name="dictKey"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.Proces``1(System.Object,System.Int32,System.Object)">
            <summary>
            Start processing the Parameter object, By this.ResultCreate() method returns
            </summary>
            <typeparam name="Type"></typeparam>
            <param name="value"></param>
            <param name="collectionIndex"></param>
            <param name="dictKey"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.ResultCreate(System.Int32)">
            <summary>
            Used to create the Proces() method returns object
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.ResultCreate(System.Int32,System.String)">
            <summary>
            Used to create the Proces() method returns object
            </summary>
            <param name="state"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.ResultCreate``1(``0,System.String,System.Int32)">
            <summary>
            Used to create the Proces() method returns object
            </summary>
            <typeparam name="Data"></typeparam>
            <param name="data"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Annotations.ArgumentAttribute.ResultCreate(System.Object,System.String,System.Int32)">
            <summary>
            Used to create the Proces() method returns object
            </summary>
            <typeparam name="Data"></typeparam>
            <param name="data"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="F:Business.Core.Annotations.FilterModel.No">
            <summary>
            Apply all parameters, including injection, without filtering
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.FilterModel.UseParameterLevel">
            <summary>
            Filter out injection parameters also parameter level annotation
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.FilterModel.UseNotParameterLevel">
            <summary>
            Filter out injection parameters also non parameter level annotation
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.FilterModel.NotUseParameterLevel">
            <summary>
            Filter out non injection parameters also parameter level annotation
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.FilterModel.NotUseNotParameterLevel">
            <summary>
            Filter out non injection parameters also non parameter level annotation
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.FilterModel.Definition">
            <summary>
            This value indicates whether it filter out custom parameters
            </summary>
        </member>
        <member name="F:Business.Core.Annotations.FilterModel.NotDefinition">
            <summary>
            This value indicates whether it applies only to non custom parameters
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.CommandAttribute">
            <summary>
            Command attribute on a method, for multiple sources to invoke the method
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.CheckEmailAttribute">
            <summary>
            https://github.com/Microsoft/referencesource/blob/master/System.ComponentModel.DataAnnotations/DataAnnotations/EmailAddressAttribute.cs
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.RegexAttribute">
            <summary>
            Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.
            https://github.com/microsoft/referencesource/blob/master/System.ComponentModel.DataAnnotations/DataAnnotations/RegularExpressionAttribute.cs
            </summary>
        </member>
        <member name="M:Business.Core.Annotations.RegexAttribute.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.
            </summary>
            <param name="pattern">The regular expression pattern to match.</param>
            <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
            <param name="state"></param>
            <param name="message"></param>
        </member>
        <member name="M:Business.Core.Annotations.RegexAttribute.Proces(System.Object)">
            <summary>
            A bitwise combination of the enumeration values that provide options for matching.
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.RegexAttribute.Pattern">
            <summary>
            Gets the regular expression pattern to use
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.RegexAttribute.MatchTimeoutInMilliseconds">
            <summary>
                Gets or sets the timeout to use when matching the regular expression pattern (in milliseconds)
                (-1 means never timeout).
            </summary>
        </member>
        <member name="M:Business.Core.Annotations.RegexAttribute.SetupRegex">
            <summary>
            Sets up the <see cref="P:Business.Core.Annotations.RegexAttribute.Regex"/> property from the <see cref="P:Business.Core.Annotations.RegexAttribute.Pattern"/> property.
            </summary>
            <exception cref="!:ArgumentException"> is thrown if the current <see cref="P:Business.Core.Annotations.RegexAttribute.Pattern"/> cannot be parsed</exception>
            <exception cref="!:InvalidOperationException"> is thrown if the current attribute is ill-formed.</exception>
            <exception cref="!:ArgumentOutOfRangeException"> thrown if <see cref="P:Business.Core.Annotations.RegexAttribute.MatchTimeoutInMilliseconds" /> is negative (except -1),
            zero or greater than approximately 24 days </exception>
        </member>
        <member name="M:Business.Core.Annotations.RegexAttribute.GetDefaultTimeout">
            <summary>
            Returns the default MatchTimeout based on UseLegacyRegExTimeout switch.
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.CheckPhoneAttribute">
            <summary>
            https://github.com/microsoft/referencesource/blob/master/System.ComponentModel.DataAnnotations/DataAnnotations/PhoneAttribute.cs
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.CheckUrlAttribute">
            <summary>
            https://github.com/microsoft/referencesource/blob/master/System.ComponentModel.DataAnnotations/DataAnnotations/UrlAttribute.cs
            https://stackoverflow.com/questions/45707293/url-validation-attribute-marks-localhost-as-invalid-url
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.AESAttribute">
            <summary>
            AES return to item1=Data and item2=Salt
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.AESAttribute.Key">
            <summary>
            key
            </summary>
        </member>
        <member name="P:Business.Core.Annotations.AESAttribute.Salt">
            <summary>
            salt
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.JsonArgAttribute">
            <summary>
            System.Text.Json.JsonSerializer.Deserialize
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.HttpFile">
            <summary>
            Simple asp.net HTTP request file
            </summary>
        </member>
        <member name="T:Business.Core.Annotations.HttpFileAttribute">
            <summary>
            Simple asp.net HTTP request file attribute
            </summary>
        </member>
        <member name="T:Business.Core.Auth.IInterceptor">
            <summary>
            IInterceptor
            </summary>
        </member>
        <member name="T:Business.Core.Auth.Interceptor">
            <summary>
            Interceptor
            </summary>
        </member>
        <member name="P:Business.Core.Auth.Interceptor.Configer">
            <summary>
            Configer
            </summary>
        </member>
        <member name="T:Business.Core.Auth.Token">
            <summary>
            A token sample
            </summary>
        </member>
        <member name="M:Business.Core.Auth.Token.ToString">
            <summary>
            JSON format
            </summary>
            <returns></returns>
        </member>
        <member name="P:Business.Core.Auth.Token.Key">
            <summary>
            The user token
            </summary>
        </member>
        <member name="P:Business.Core.Auth.Token.Remote">
            <summary>
            Remote IP address
            </summary>
        </member>
        <member name="P:Business.Core.Auth.Token.Callback">
            <summary>
            Gets the token of this result, used for callback
            </summary>
        </member>
        <member name="M:Business.Core.Utils.BootstrapExtensions.UseType``1(``0,System.Type[])">
            <summary>
            Inject a parameter type, depending on the parameter type
            </summary>
            <param name="bootstrap"></param>
            <param name="parameterType"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.BootstrapExtensions.UseType``1(``0,System.String[])">
            <summary>
            Inject a parameter type, depending on the parameter name
            </summary>
            <typeparam name="Bootstrap"></typeparam>
            <param name="bootstrap"></param>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.BootstrapExtensions.LoggerSet``1(``0,Business.Core.Annotations.LoggerAttribute,System.Type[])">
            <summary>
            Set the log characteristics of a parameter, depending on the parameter type
            </summary>
            <param name="bootstrap"></param>
            <param name="logger"></param>
            <param name="argType"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.BootstrapExtensions.LoggerSet``1(``0,Business.Core.Annotations.LoggerAttribute,System.String[])">
            <summary>
            Set the log characteristics of a parameter, depending on the parameter name
            </summary>
            <param name="bootstrap"></param>
            <param name="logger"></param>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.BootstrapExtensions.IgnoreSet``1(``0,Business.Core.Annotations.Ignore,System.String[])">
            <summary>
            Set a parameter's ignore feature, depending on the parameter name
            </summary>
            <param name="bootstrap"></param>
            <param name="ignore"></param>
            <param name="parameterName"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Emit.Emit.GetDeclaringType(System.Reflection.MethodInfo)">
            <summary>
            Gets the declaring type of the target <paramref name="method"/>.
            </summary>
            <param name="method">The <see cref="T:System.Reflection.MethodInfo"/> for which to return the declaring type.</param>
            <returns>The type that declares the target <paramref name="method"/>.</returns>
        </member>
        <member name="T:Business.Core.Utils.Emit.IDynamicMethodSkeleton">
            <summary>
            Represents the skeleton of a dynamic method.
            </summary>    
        </member>
        <member name="M:Business.Core.Utils.Emit.IDynamicMethodSkeleton.GetILGenerator">
            <summary>
            Gets the <see cref="T:System.Reflection.Emit.ILGenerator"/> used to emit the method body.
            </summary>
            <returns>An <see cref="T:System.Reflection.Emit.ILGenerator"/> instance.</returns>
        </member>
        <member name="M:Business.Core.Utils.Emit.IDynamicMethodSkeleton.CreateDelegate">
            <summary>
            Create a delegate used to invoke the dynamic method.
            </summary>
            <returns>A function delegate.</returns>
        </member>
        <member name="T:Business.Core.Utils.Emit.IMethodBuilder">
            <summary>
            Represents a class that is capable of creating a delegate used to invoke 
            a method without using late-bound invocation.
            </summary>
        </member>
        <member name="M:Business.Core.Utils.Emit.IMethodBuilder.GetDelegate(System.Reflection.MethodInfo)">
            <summary>
            Gets a delegate that is used to invoke the <paramref name="targetMethod"/>.
            </summary>
            <param name="targetMethod">The <see cref="T:System.Reflection.MethodInfo"/> that represents the target method to invoke.</param>
            <returns>A delegate that represents compiled code used to invoke the <paramref name="targetMethod"/>.</returns>
        </member>
        <member name="T:Business.Core.Utils.Emit.DynamicMethodBuilder">
            <summary>
            A class that is capable of creating a delegate used to invoke 
            a method without using late-bound invocation.
            </summary>
        </member>
        <member name="M:Business.Core.Utils.Emit.DynamicMethodBuilder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Business.Core.Utils.Emit.DynamicMethodBuilder"/> class.
            </summary>
        </member>
        <member name="M:Business.Core.Utils.Emit.DynamicMethodBuilder.GetDelegate(System.Reflection.MethodInfo)">
            <summary>
            Gets a delegate that is used to invoke the <paramref name="targetMethod"/>.
            </summary>
            <param name="targetMethod">The <see cref="T:System.Reflection.MethodInfo"/> that represents the target method to invoke.</param>
            <returns>A delegate that represents compiled code used to invoke the <paramref name="targetMethod"/>.</returns>
        </member>
        <member name="M:Business.Core.Utils.Emit.DynamicMethodBuilder.DynamicMethodSkeleton.GetILGenerator">
            <summary>
            Gets the <see cref="T:System.Reflection.Emit.ILGenerator"/> used to emit the method body.
            </summary>
            <returns>An <see cref="T:System.Reflection.Emit.ILGenerator"/> instance.</returns>
        </member>
        <member name="M:Business.Core.Utils.Emit.DynamicMethodBuilder.DynamicMethodSkeleton.CreateDelegate">
            <summary>
            Create a delegate used to invoke the dynamic method.
            </summary>
            <returns>A function delegate.</returns>
        </member>
        <member name="M:Business.Core.Utils.Help.GroupEquals(Business.Core.Annotations.GroupAttribute,System.String)">
            <summary>
            string.IsNullOrWhiteSpace(x.Group) || x.Group == group
            </summary>
            <param name="x"></param>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Help.UseDoc``1(``0,System.String,Business.Core.Document.Config)">
            <summary>
            Generate "Business.Document.DocArg" Document Objects for the specified business class.
            </summary>
            <typeparam name="Business"></typeparam>
            <param name="business"></param>
            <param name="outDir"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Help.UseDoc``2(``0,System.Func{Business.Core.Document.DocArgSource{Business.Core.Meta.Args},``1},System.String,Business.Core.Document.Config)">
            <summary>
            Generate document objects for specified business classes.
            </summary>
            <typeparam name="Business"></typeparam>
            <typeparam name="DocArg"></typeparam>
            <param name="business"></param>
            <param name="argCallback"></param>
            <param name="outDir"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Help.UseDoc``2(``0,System.Func{Business.Core.Document.DocArgSource{Business.Core.Meta.Args},``1},System.Collections.Generic.IDictionary{System.String,Business.Core.Document.Xml.member},Business.Core.Document.Config)">
            <summary>
            Gets the document object of the specified business class.
            </summary>
            <typeparam name="Business"></typeparam>
            <typeparam name="DocArg"></typeparam>
            <param name="business"></param>
            <param name="argCallback"></param>
            <param name="xmlMembers"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Help.GZipDecompressByte(System.Byte[])">
            <summary>
            gzip to byte[]
            </summary>
            <param name="value">byte[]</param>
            <returns>byte[]</returns>
        </member>
        <member name="M:Business.Core.Utils.Help.GZipDecompressStream(System.Byte[])">
            <summary>
            gzip to byte[]
            </summary>
            <param name="value">byte[]</param>
            <returns>MemoryStream</returns>
        </member>
        <member name="M:Business.Core.Utils.Help.AES.Encrypt(System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            AES return to item1=Data and item2=Salt
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <param name="iv"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Help.ExceptionWrite(System.Exception,System.Boolean,System.Boolean,System.String,System.String,System.Text.Encoding)">
            <summary>
            Write exception to file
            </summary>
            <param name="ex"></param>
            <param name="write"></param>
            <param name="console"></param>
            <param name="path"></param>
            <param name="dateFormat"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Help.WriteLocal(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.String,System.Text.Encoding)">
            <summary>
            Write text to file
            </summary>
            <param name="text"></param>
            <param name="path"></param>
            <param name="autoTime"></param>
            <param name="write"></param>
            <param name="console"></param>
            <param name="dateFormat"></param>
        </member>
        <member name="F:Business.Core.Utils.Help.UTF8">
            <summary>
            Ignore erroneous characters: Unable to translate Unicode...
            </summary>
        </member>
        <member name="M:Business.Core.Utils.Help.UTF8String(System.String)">
            <summary>
            Ignore erroneous characters: Unable to translate Unicode...
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:Business.Core.Utils.Help.CheckCharMode.All">
            <summary>
            Allow all
            </summary>
        </member>
        <member name="F:Business.Core.Utils.Help.CheckCharMode.Number">
            <summary>
            Allow number
            </summary>
        </member>
        <member name="F:Business.Core.Utils.Help.CheckCharMode.Upper">
            <summary>
            Allow upper
            </summary>
        </member>
        <member name="F:Business.Core.Utils.Help.CheckCharMode.Lower">
            <summary>
            Allow lower
            </summary>
        </member>
        <member name="F:Business.Core.Utils.Help.CheckCharMode.Chinese">
            <summary>
            Allow chinese
            </summary>
        </member>
        <member name="P:Business.Core.Utils.Help.Guid">
            <summary>
            ToString("N")
            </summary>
        </member>
        <member name="M:Business.Core.Utils.Help.CreateInstance(System.Type)">
            <summary>
            general object creation
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Utils.Help.IsArray(System.Type)">
            <summary>
            Checks if a type is an array or not
            </summary>
            <param name="source">The type to check.</param>
            <returns><see langword="true" /> if the type is an array, otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Business.Core.Utils.Help.IsCollection(System.Type)">
            <summary>
            Checks if a type is an collection or not
            </summary>
            <param name="source">The type to check.</param>
            <returns><see langword="true" /> if the type is an collection, otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Business.Core.Utils.Help.IsEnumerable(System.Type)">
            <summary>
            Checks if a type is enumerable or not
            </summary>
            <param name="source">The type to check.</param>
            <returns><see langword="true" /> if the type is an enumerable, otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Business.Core.Utils.Help.IsNumeric(System.Type)">
            <summary>
            Determines if a type is numeric.  Nullable numeric types are considered numeric.
            </summary>
            <remarks>
            Boolean is not considered numeric.
            </remarks>
        </member>
        <member name="M:Business.Core.Utils.Help.NotOfType``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters our all types not assignable to <typeparamref name="TType"/>.
            </summary>
            <typeparam name="TType">The type that all resulting <see cref="!:Type"/> should be assignable to.</typeparam>
            <param name="types">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="!:Type"/> instances that should be filtered.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="!:Type"/> instances.</returns>
        </member>
        <member name="M:Business.Core.Utils.Help.IsAssignableToGenericType(System.Type,System.Type)">
            <summary>
            Determines whether the <paramref name="genericType"/> is assignable from
            <paramref name="givenType"/> taking into account generic definitions
            </summary>
            <remarks>
            Borrowed from: http://tmont.com/blargh/2011/3/determining-if-an-open-generic-type-isassignablefrom-a-type
            </remarks>
        </member>
        <member name="P:Business.Core.Utils.Queue`1.BatchOptions.Interval">
            <summary>
            Return log time interval, default System.TimeSpan.Zero equals not enabled,5 seconds is reasonable
            </summary>
        </member>
        <member name="P:Business.Core.Utils.Queue`1.BatchOptions.MaxNumber">
            <summary>
            Return log number, less than 1 no restrictions
            </summary>
        </member>
        <member name="M:Business.Core.Utils.Queue`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0},System.Threading.Tasks.Task},Business.Core.Utils.Queue{`0}.BatchOptions,System.Int32,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Queue
            </summary>
            <param name="call"></param>
            <param name="batch"></param>
            <param name="maxWorkThreads">Gets the maximum out queue thread for this queue, default 1</param>
            <param name="syn">Whether each outgoing thread has synchronous callback, asynchronous by default</param>
            <param name="maxCapacity">Gets the max capacity of this queue</param>
        </member>
        <member name="P:Business.Core.IArg.In">
            <summary>
            The first input object
            </summary>
        </member>
        <member name="P:Business.Core.IArg.Out">
            <summary>
            The final output object
            </summary>
        </member>
        <member name="T:Business.Core.Arg`2">
            <summary>
            This is a parameter package, used to transform parameters
            </summary>
            <typeparam name="OutType"></typeparam>
            <typeparam name="InType"></typeparam>
        </member>
        <member name="P:Business.Core.Arg`2.Out">
            <summary>
            The final output object
            </summary>
        </member>
        <member name="P:Business.Core.Arg`2.In">
            <summary>
            The first input object
            </summary>
        </member>
        <member name="T:Business.Core.Arg`1">
            <summary>
            This is a parameter package, used to transform parameters
            </summary>
            <typeparam name="OutType"></typeparam>
        </member>
        <member name="P:Business.Core.Arg`1.Out">
            <summary>
            The final output object
            </summary>
        </member>
        <member name="P:Business.Core.Arg`1.In">
            <summary>
            The first input object
            </summary>
        </member>
        <member name="T:Business.Core.CommandGroup">
            <summary>
            Command grouping
            </summary>
        </member>
        <member name="T:Business.Core.Meta.Args">
            <summary>
            Argument
            </summary>
        </member>
        <member name="P:Business.Core.Meta.Args.MemberDefinition">
            <summary>
            xml using
            </summary>
        </member>
        <member name="M:Business.Core.Bootstrap.Create``1(System.Object[])">
            <summary>
            Initialize a Generic proxy class
            </summary>
            <typeparam name="Business"></typeparam>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Bootstrap.Create``1(Business.Core.Auth.IInterceptor,System.Object[])">
            <summary>
            Initialize a Generic proxy class
            </summary>
            <typeparam name="Business"></typeparam>
            <param name="interceptor"></param>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Bootstrap.Create(System.Type,Business.Core.Auth.IInterceptor,System.Object[])">
            <summary>
            Initialize a Type proxy class
            </summary>
            <param name="type"></param>
            <param name="interceptor"></param>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Bootstrap.Create(System.Object[])">
            <summary>
            bootstrap all Business class
            </summary>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Bootstrap.Create(Business.Core.Auth.IInterceptor,System.Object[])">
            <summary>
            bootstrap all Business class
            </summary>
            <param name="interceptor"></param>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Bootstrap.UseDoc(System.String,Business.Core.Document.Config)">
            <summary>
            Generating Document Model for All Business Classes. business.doc
            </summary>
            <param name="outDir"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Bootstrap`1.UseDoc(System.String,Business.Core.Document.Config)">
            <summary>
            Generating Document Model for All Business Classes. business.doc
            </summary>
            <param name="outDir"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.BootstrapAll.Build(System.String[],System.String[])">
            <summary>
            Load all business classes in the run directory
            </summary>
            <param name="assemblyFiles"></param>
            <param name="businessTypeFullName"></param>
        </member>
        <member name="M:Business.Core.BootstrapAll.UseDoc(System.String,Business.Core.Document.Config)">
            <summary>
            Generating Document Model for All Business Classes. business.doc
            </summary>
            <param name="outDir"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:Business.Core.Document.Config.Debug">
            <summary>
            Whether to render the Debug element in the UI
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.Benchmark">
            <summary>
            Whether to render the Benchmark element in the UI
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.Testing">
            <summary>
            Whether to render the Testing element in the UI
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.Group">
            <summary>
            Generate only documents for the specified group
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.GroupSelect">
            <summary>
            Currently selected group
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.GroupEnable">
            <summary>
            Whether to render the Group element in the UI
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.SetToken">
            <summary>
            Whether to render the SetToken element in the UI
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.Navigtion">
            <summary>
            Whether to open the side navigation bar
            </summary>
        </member>
        <member name="P:Business.Core.Document.Config.BenchmarkJSON">
            <summary>
            Benchmark tests whether the passed parameters are JSON serialized. By default false, does not need to be serialized
            </summary>
        </member>
        <member name="P:Business.Core.Document.Doc`1.Alias">
            <summary>
            Friendly name
            </summary>
        </member>
        <member name="M:Business.Core.Document.Doc`1.ToString">
            <summary>
            Json format
            </summary>
            <returns></returns>
        </member>
        <member name="P:Business.Core.Document.Member`1.Alias">
            <summary>
            Friendly name
            </summary>
        </member>
        <member name="P:Business.Core.Document.Member`1.AliasGroup">
            <summary>
            Friendly name group
            </summary>
        </member>
        <member name="P:Business.Core.Document.Testing.Name">
            <summary>
            test key
            </summary>
        </member>
        <member name="P:Business.Core.Document.Testing.Value">
            <summary>
            test args
            </summary>
        </member>
        <member name="P:Business.Core.Document.Testing.Result">
            <summary>
            test result check
            </summary>
        </member>
        <member name="P:Business.Core.Document.Testing.Token">
            <summary>
            test fixed roken
            </summary>
        </member>
        <member name="P:Business.Core.Document.Testing.TokenMethod">
            <summary>
            Support method Result.D, input json array [\"Login\",\"{User:\\\"aaa\\\",Password:\\\"123456\\\"}\"]
            </summary>
        </member>
        <member name="P:Business.Core.IBusiness.Logger">
            <summary>
            Log subscription queue
            </summary>
        </member>
        <member name="P:Business.Core.IBusiness.Command">
            <summary>
            Call methods by command
            </summary>
        </member>
        <member name="P:Business.Core.IBusiness.Configer">
            <summary>
            Configurer
            </summary>
        </member>
        <member name="P:Business.Core.IBusiness.BindAfter">
            <summary>
            After binding
            </summary>
        </member>
        <member name="P:Business.Core.IBusiness.BindBefore">
            <summary>
            Before binding
            </summary>
        </member>
        <member name="M:Business.Core.IBusiness.ResultCreate(System.Int32,System.String,System.String)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <param name="state"></param>
            <param name="message"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.IBusiness.ResultCreate``1(``0,System.String,System.Int32)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <typeparam name="Data"></typeparam>
            <param name="data"></param>
            <param name="message"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.IBusiness.ResultCreate(System.Object,System.String,System.Int32)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <param name="data"></param>
            <param name="message"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="P:Business.Core.BusinessBase`2.Logger">
            <summary>
            Log subscription queue
            </summary>
        </member>
        <member name="P:Business.Core.BusinessBase`2.Command">
            <summary>
            Call methods by command
            </summary>
        </member>
        <member name="P:Business.Core.BusinessBase`2.Configer">
            <summary>
            Configurer
            </summary>
        </member>
        <member name="P:Business.Core.BusinessBase`2.BindAfter">
            <summary>
            After binding
            </summary>
        </member>
        <member name="P:Business.Core.BusinessBase`2.BindBefore">
            <summary>
            Before binding
            </summary>
        </member>
        <member name="M:Business.Core.BusinessBase`2.ResultCreate(System.Int32,System.String,System.String)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <param name="state"></param>
            <param name="message"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.BusinessBase`2.ResultCreate``1(``0,System.String,System.Int32)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <typeparam name="Data"></typeparam>
            <param name="data"></param>
            <param name="message"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.BusinessBase`2.ResultCreate(System.Object,System.String,System.Int32)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <param name="data"></param>
            <param name="message"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="T:Business.Core.Logger">
            <summary>
            Log subscription queue
            </summary>
        </member>
        <member name="T:Business.Core.Logger.LoggerValueType">
            <summary>
            Logger value type
            </summary>
        </member>
        <member name="F:Business.Core.Logger.LoggerValueType.All">
            <summary>
            In
            </summary>
        </member>
        <member name="F:Business.Core.Logger.LoggerValueType.In">
            <summary>
            In
            </summary>
        </member>
        <member name="F:Business.Core.Logger.LoggerValueType.Out">
            <summary>
            Out
            </summary>
        </member>
        <member name="T:Business.Core.Logger.Type">
            <summary>
            Needs of the logging categories
            </summary>
        </member>
        <member name="F:Business.Core.Logger.Type.All">
            <summary>
            All
            </summary>
        </member>
        <member name="F:Business.Core.Logger.Type.Record">
            <summary>
            Record
            </summary>
        </member>
        <member name="F:Business.Core.Logger.Type.Error">
            <summary>
            Error
            </summary>
        </member>
        <member name="F:Business.Core.Logger.Type.Exception">
            <summary>
            Exception
            </summary>
        </member>
        <member name="T:Business.Core.Logger.LoggerData">
            <summary>
            Logger data object
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.Token">
            <summary>
            token
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.Type">
            <summary>
            Logger type
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.Value">
            <summary>
            The parameters of the method
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.Result">
            <summary>
            The method's Return Value
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.Time">
            <summary>
            Method execution time
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.Member">
            <summary>
            Method full name
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.Group">
            <summary>
            Used for the command group
            </summary>
        </member>
        <member name="M:Business.Core.Logger.LoggerData.ToString">
            <summary>
            Json format
            </summary>
            <returns></returns>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.LoggerDataJson.Token">
            <summary>
            token
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.LoggerDataJson.Type">
            <summary>
            Logger type
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.LoggerDataJson.Value">
            <summary>
            The parameters of the method
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.LoggerDataJson.Result">
            <summary>
            The method's Return Value
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.LoggerDataJson.Time">
            <summary>
            Method execution time
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.LoggerDataJson.Member">
            <summary>
            Method full name
            </summary>
        </member>
        <member name="P:Business.Core.Logger.LoggerData.LoggerDataJson.Group">
            <summary>
            Used for the command group
            </summary>
        </member>
        <member name="P:Business.Core.Logger.BatchOptions.Interval">
            <summary>
            Return log time interval, default System.TimeSpan.Zero equals not enabled, x seconds is reasonable
            </summary>
        </member>
        <member name="P:Business.Core.Logger.BatchOptions.MaxNumber">
            <summary>
            Return log number, less than 1 no restrictions
            </summary>
        </member>
        <member name="M:Business.Core.Logger.#ctor(System.Func{System.Collections.Generic.IEnumerable{Business.Core.Logger.LoggerData},System.Threading.Tasks.Task},Business.Core.Logger.BatchOptions,System.Int32,System.Boolean,System.Nullable{System.Int32},Business.Core.Logger.LoggerValueType)">
            <summary>
            Logger
            </summary>
            <param name="call"></param>
            <param name="batch"></param>
            <param name="maxWorkThreads">Gets the maximum out queue thread for this queue, default 1</param>
            <param name="syn">Whether each outgoing thread has synchronous callback, asynchronous by default</param>
            <param name="maxCapacity">Gets the max capacity of this queue</param>
            <param name="loggerValueType"></param>
        </member>
        <member name="F:Business.Core.Configer.Routes">
            <summary>
            Business
            Business + Group
            Business + Command + Group
            </summary>
        </member>
        <member name="F:Business.Core.Configer.DocJsonSettings">
            <summary>
            FirstCharToLowerNamingPolicy
            </summary>
        </member>
        <member name="P:Business.Core.Configer.Logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="P:Business.Core.Configer.CallBeforeMethod">
            <summary>
            Before the method is successfully invoked
            </summary>
        </member>
        <member name="P:Business.Core.Configer.CallAfterMethod">
            <summary>
            After the method has been successfully invoked
            </summary>
        </member>
        <member name="P:Business.Core.Configer.MemberSetAfter">
            <summary>
            After the MemberSet has been successfully invoked
            </summary>
        </member>
        <member name="P:Business.Core.Result.IResult.State">
            <summary>
            The results of the state is greater than or equal 
            to 1: success, equal to 0: system level exceptions, less than 0: business class error.
            </summary>
        </member>
        <member name="P:Business.Core.Result.IResult.Message">
            <summary>
            Success can be null
            </summary>
        </member>
        <member name="P:Business.Core.Result.IResult.Data">
            <summary>
            Specific Byte/Json data objects
            </summary>
        </member>
        <member name="P:Business.Core.Result.IResult.HasData">
            <summary>
            Whether there is value
            </summary>
        </member>
        <member name="P:Business.Core.Result.IResult.Callback">
            <summary>
            Gets the token of this result, used for callback
            </summary>
        </member>
        <member name="M:Business.Core.Result.IResult.ToDataString">
            <summary>
            Json Data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.IResult.ToDataBytes">
            <summary>
            Byte Data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.IResult.ToBytes">
            <summary>
            ProtoBuf,MessagePack or Other
            </summary>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.IResult.ToString">
            <summary>
            Json
            </summary>
            <returns></returns>
        </member>
        <member name="P:Business.Core.Result.IResult.GenericDefinition">
            <summary>
            System.Type object that represents a generic type definition from which the current generic type can be constructed.
            </summary>
        </member>
        <member name="P:Business.Core.Result.IResult`1.Data">
            <summary>
            Specific Byte/Json data objects
            </summary>
        </member>
        <member name="M:Business.Core.Result.ResultFactory.ResultCreate(System.Type,System.Type,System.Int32,System.String)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <param name="resultType"></param>
            <param name="resultTypeDefinition"></param>
            <param name="state"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultFactory.ResultCreate(Business.Core.Meta.MetaData,System.Int32,System.String)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <param name="meta"></param>
            <param name="state"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultFactory.ResultCreate``1(System.Type,``0,System.String,System.Int32,System.Boolean)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <typeparam name="Data"></typeparam>
            <param name="resultTypeDefinition"></param>
            <param name="data"></param>
            <param name="message"></param>
            <param name="state"></param>
            <param name="checkData"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultFactory.ResultCreate(System.Type,System.Int32,System.String)">
            <summary>
            Used to create the IResult returns object
            </summary>
            <param name="resultTypeDefinition"></param>
            <param name="state"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultFactory.ResultCreateToDataBytes(Business.Core.Result.IResult)">
            <summary>
            Used to create IResult.Data secondary encapsulation
            </summary>
            <param name="resultType"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultFactory.ResultCreateToDataString(Business.Core.Result.IResult)">
            <summary>
            Used to create IResult.Data secondary encapsulation
            </summary>
            <param name="resultType"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:Business.Core.Result.ResultObject`1">
            <summary>
            result
            </summary>
            <typeparam name="Type"></typeparam>
        </member>
        <member name="M:Business.Core.Result.ResultObject`1.#ctor(System.Type,`0,System.Int32,System.String,System.Type,System.Boolean)">
            <summary>
            /Activator.CreateInstance
            </summary>
            <param name="dataType"></param>
            <param name="data"></param>
            <param name="state"></param>
            <param name="message"></param>
            <param name="genericDefinition"></param>
            <param name="checkData"></param>
        </member>
        <member name="M:Business.Core.Result.ResultObject`1.#ctor(`0,System.Int32,System.String)">
            <summary>
            MessagePack.MessagePackSerializer.Serialize(this)
            </summary>
            <param name="data"></param>
            <param name="state"></param>
            <param name="message"></param>
        </member>
        <member name="P:Business.Core.Result.ResultObject`1.State">
            <summary>
            The results of the state is greater than or equal to 1: success, equal to 0: system level exceptions, less than 0: business class error.
            </summary>
        </member>
        <member name="P:Business.Core.Result.ResultObject`1.Message">
            <summary>
            Success can be null
            </summary>
        </member>
        <member name="P:Business.Core.Result.ResultObject`1.Business#Core#Result#IResult#Data">
            <summary>
            Specific dynamic data objects
            </summary>
        </member>
        <member name="P:Business.Core.Result.ResultObject`1.Data">
            <summary>
            Specific Byte/Json data objects
            </summary>
        </member>
        <member name="P:Business.Core.Result.ResultObject`1.HasData">
            <summary>
            Whether there is value
            </summary>
        </member>
        <member name="P:Business.Core.Result.ResultObject`1.Callback">
            <summary>
            Gets the token of this result, used for callback
            </summary>
        </member>
        <member name="M:Business.Core.Result.ResultObject`1.ToString">
            <summary>
            Json format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultObject`1.ToDataString">
            <summary>
            Json format Data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultObject`1.ToBytes">
            <summary>
            ProtoBuf format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Business.Core.Result.ResultObject`1.ToDataBytes">
            <summary>
            ProtoBuf format Data
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
